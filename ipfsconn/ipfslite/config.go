package ipfslite

import (
	"encoding/json"
	"errors"
	"fmt"
	"time"

	ipfslite "github.com/hsanjuan/ipfs-lite"
	"github.com/kelseyhightower/envconfig"

	"github.com/ipfs-cluster/ipfs-cluster/config"
)

const configKey = "ipfslite"
const envConfigKey = "cluster_ipfslite"

// DefaultListenAddrs contains TCP and QUIC listen addresses.
var DefaultListenAddrs = []string{
	"/ip4/0.0.0.0/tcp/4001",
	"/ip4/0.0.0.0/udp/4001/quic-v1",
}

// Default values for Config.
const (
	DefaultOffline                 = false
	DefaultReproviderInterval      = 12 * time.Hour
	DefaultUncachedBlockstore      = false
	DefaultConnectSwarmsDelay      = 30 * time.Second
	DefaultPinTimeout              = 2 * time.Minute
	DefaultUnpinTimeout            = 3 * time.Hour
	DefaultRepoGCTimeout           = 24 * time.Hour
	DefaultInformerTriggerInterval = 0 // disabled
	DefaultUnpinDisable            = false
)

// Config is used to initialize a Connector and allows to customize
// its behavior. It implements the config.ComponentConfig interface.
type Config struct {
	config.Saver

	// Listen addresses ipfs-lite libp2p host.
	ListenAddresses []ma.Multiaddr

	ipfslite.Config

	// ConnectSwarmsDelay specifies how long to wait after startup before
	// attempting to open connections from this peer's ipfslite peer to the
	// IPFS peers of other peers.
	ConnectSwarmsDelay time.Duration

	// Pin Operation timeout
	PinTimeout time.Duration

	// Unpin Operation timeout
	UnpinTimeout time.Duration

	// RepoGC Operation timeout
	RepoGCTimeout time.Duration

	// How many pin and block/put operations need to happen before we do a
	// special broadcast informer metrics to the network. 0 to disable.
	InformerTriggerInterval int

	// Disables the unpin operation and returns an error.
	UnpinDisable bool
}

type jsonConfig struct {
	ListenMultiaddresses    []string `json:"listen_multiaddresses"`
	Offline                 bool     `json:"offline"`
	ReproviderInterval      int      `json:"reprovider_interval"`
	UncachedBlockstore      bool     `json:"uncached_blockstore"`
	ConnectSwarmsDelay      string   `json:"connect_swarms_delay"`
	PinTimeout              string   `json:"pin_timeout"`
	UnpinTimeout            string   `json:"unpin_timeout"`
	RepoGCTimeout           string   `json:"repogc_timeout"`
	InformerTriggerInterval int      `json:"informer_trigger_interval"`
	UnpinDisable            bool     `json:"unpin_disable,omitempty"`
}

// ConfigKey provides a human-friendly identifier for this type of Config.
func (cfg *Config) ConfigKey() string {
	return configKey
}

// Default sets the fields of this Config to sensible default values.
func (cfg *Config) Default() error {
	cfg.ListenAddresses = DefaultListenAddresses
	cfg.Lite.Offline = DefaultOffline
	cfg.Lite.ReproviderInterval = DefaultReproviderInterval
	cfg.Lite.UnchachedBlockstore = DefaultUncachedBlockstore
	cfg.ConnectSwarmsDelay = DefaultConnectSwarmsDelay
	cfg.PinTimeout = DefaultPinTimeout
	cfg.UnpinTimeout = DefaultUnpinTimeout
	cfg.RepoGCTimeout = DefaultRepoGCTimeout
	cfg.InformerTriggerInterval = DefaultInformerTriggerInterval
	cfg.UnpinDisable = DefaultUnpinDisable

	return nil
}

// ApplyEnvVars fills in any Config fields found
// as environment variables.
func (cfg *Config) ApplyEnvVars() error {
	jcfg, err := cfg.toJSONConfig()
	if err != nil {
		return err
	}

	err = envconfig.Process(envConfigKey, jcfg)
	if err != nil {
		return err
	}

	return cfg.applyJSONConfig(jcfg)
}

// Validate checks that the fields of this Config have sensible values,
// at least in appearance.
func (cfg *Config) Validate() error {
	var err error
	if len(cfg.ListenAddresses) == 0 && !cfg.Offline {
		err = errors.New("ipfslite.listen_multiaddresses must have a value when not offline")
	}

	if cfg.Lite.ReproviderInterval < 0 {
		err = errors.New("ipfslite.reprovider_interval is invalid")
	}

	if cfg.ConnectSwarmsDelay < 0 {
		err = errors.New("ipfslite.connect_swarms_delay is invalid")
	}

	if cfg.IPFSRequestTimeout < 0 {
		err = errors.New("ipfslite.ipfs_request_timeout invalid")
	}

	if cfg.PinTimeout < 0 {
		err = errors.New("ipfslite.pin_timeout invalid")
	}

	if cfg.UnpinTimeout < 0 {
		err = errors.New("ipfslite.unpin_timeout invalid")
	}

	if cfg.RepoGCTimeout < 0 {
		err = errors.New("ipfslite.repogc_timeout invalid")
	}
	if cfg.InformerTriggerInterval < 0 {
		err = errors.New("ipfslite.update_metrics_after")
	}

	return err

}

// LoadJSON parses a JSON representation of this Config as generated by ToJSON.
func (cfg *Config) LoadJSON(raw []byte) error {
	jcfg := &jsonConfig{}
	err := json.Unmarshal(raw, jcfg)
	if err != nil {
		logger.Error("Error unmarshaling ipfslite config")
		return err
	}

	cfg.Default()

	return cfg.applyJSONConfig(jcfg)
}

func (cfg *Config) applyJSONConfig(jcfg *jsonConfig) error {
	if addresses := jcfg.ListenMultiaddresses; len(addresses) > 0 {
		cfg.ListenAddresses = make([]ma.Multiaddr, 0, len(addresses))
		for _, addr := range addresses {
			p2pAddr, err := ma.NewMultiaddr(addr)
			if err != nil {
				err = fmt.Errorf("error parsing %s.listen_multiaddresses: %s", cfg.ConfigKey, err)
				return err
			}
			cfg.ListenAddresses = append(cfg.ListenAddresses, p2pAddr)
		}
	}

	cfg.Lite.Offline = jcfg.Offline
	cfg.Lite.UnchachedBlockstore = jcfg.UncachedBlockstore
	cfg.UnpinDisable = jcfg.UnpinDisable
	cfg.InformerTriggerInterval = jcfg.InformerTriggerInterval

	err = config.ParseDurations(
		"ipfslite",
		&config.DurationOpt{Duration: jcfg.ReproviderInterval, Dst: &cfg.Lite.ReproviderInterval, Name: "reprovider_interval"},
		&config.DurationOpt{Duration: jcfg.ConnectSwarmsDelay, Dst: &cfg.ConnectSwarmsDelay, Name: "connect_swarms_delay"},
		&config.DurationOpt{Duration: jcfg.IPFSRequestTimeout, Dst: &cfg.IPFSRequestTimeout, Name: "ipfs_request_timeout"},
		&config.DurationOpt{Duration: jcfg.PinTimeout, Dst: &cfg.PinTimeout, Name: "pin_timeout"},
		&config.DurationOpt{Duration: jcfg.UnpinTimeout, Dst: &cfg.UnpinTimeout, Name: "unpin_timeout"},
		&config.DurationOpt{Duration: jcfg.RepoGCTimeout, Dst: &cfg.RepoGCTimeout, Name: "repogc_timeout"},
	)
	if err != nil {
		return err
	}

	return cfg.Validate()
}

// ToJSON generates a human-friendly JSON representation of this Config.
func (cfg *Config) ToJSON() (raw []byte, err error) {
	jcfg, err := cfg.toJSONConfig()
	if err != nil {
		return
	}

	raw, err = config.DefaultJSONMarshal(jcfg)
	return
}

func (cfg *Config) toJSONConfig() (jcfg *jsonConfig, err error) {
	// Multiaddress String() may panic
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("%s", r)
		}
	}()

	jcfg = &jsonConfig{}

	listenAddresses := make([]string, 0, len(cfg.ListenAddresses))
	for _, addr := range cfg.ListenAddresses {
		listenAddresses = append(listenAddresses, addr.String())
	}

	// Set all configuration fields
	jcfg.ListenMultiaddresses = listenAddresses
	jcfg.Offline = cfg.Lite.Offline
	jcfg.ReproviderInterval = cfg.Lite.ReproviderInterval.String()
	jcfg.UncachedBlockstore = DefaultUncachedBlockstore
	jcfg.ConnectSwarmsDelay = cfg.ConnectSwarmsDelay.String()
	jcfg.PinTimeout = cfg.PinTimeout.String()
	jcfg.UnpinTimeout = cfg.UnpinTimeout.String()
	jcfg.RepoGCTimeout = cfg.RepoGCTimeout.String()
	jcfg.InformerTriggerInterval = cfg.InformerTriggerInterval
	jcfg.UnpinDisable = cfg.UnpinDisable

	return
}

// ToDisplayJSON returns JSON config as a string.
func (cfg *Config) ToDisplayJSON() ([]byte, error) {
	jcfg, err := cfg.toJSONConfig()
	if err != nil {
		return nil, err
	}

	return config.DisplayJSON(jcfg)
}
